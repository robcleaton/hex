---
title: Lava
layout: basic
permalink: /lava
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>{{ page.title }}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

    <!-- Site CSS -->
    <link rel="stylesheet" href="assets/css/styles.css" type="text/css">

    <!-- Google Gabarito font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Gabarito:wght@400..900&display=swap" rel="stylesheet">
  </head>

  <body>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>


<style>
  *, *:before, *:after {
    margin: 0;
    padding: 0;
  }

  body {
    overflow: hidden;
  }

  #toggleBlur {
    position: absolute;
    top: 1em;
    right: 1em;
    z-index: 1;
    padding: 0.5em;
    font-size: 0.75em;
  }

</style>

<!-- pixi inserts itself by default -->

<button id="toggleBlur" data-amount="0">Toggle Orb Blur</button>

<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>


<script>
  // Create a PixiJS application of type cavas with specify background color and make it resizes to the iframe window
  const app = new PIXI.Application({
    background: "#4cc9f0",
    resizeTo: window
  });

  // Adding the application's view to the DOM
  document.body.appendChild(app.view);

  // Basic settings
  app.stage.eventMode = "dynamic";
  app.stage.hitArea = app.screen;

  // Create container for orbs
  const container = new PIXI.Container();
  app.stage.addChild(container);

  // Make a nice color pallete for our random orbs
  const colors = ["0x4361ee", "0x3a0ca3", "0x7209b7", "0xf72585"];
  const blurFilter2 = new PIXI.BlurFilter();

  // Helper Functions

  function randomCircle() {
    const circle = new PIXI.Graphics();
    // create random circle
    const randomColor = Math.floor(Math.random() * colors.length);
    circle.beginFill(colors[randomColor]);
    circle.drawCircle(0, 0, (Math.random() * app.screen.width) / 4);
    circle.endFill();
    // generateTexture converts a graphic to a texture, which can be used to
    // create a sprite
    const texture = app.renderer.generateTexture(circle);
    return {
      texture
    };
  }

  // Orbs
  const orbs = [];

  // orb vars
  let trackSpeed = 0.03;
  let rotationSpeed = 0.01;

  // set wrapping boundaries (invisible rectangle) to be roughly equal to orb size
  const padding = app.screen.width / 4;
  const bounds = new PIXI.Rectangle(
    -padding,
    -padding,
    app.screen.width + padding * 2,
    app.screen.height + padding * 2
  );

  // create 20 orbs with randomized variables
  for (let i = 0; i < 20; i++) {
    const orb = PIXI.Sprite.from(randomCircle().texture);

    orb.anchor.set(0.5);
    container.addChild(orb);

    orb.direction = Math.random() * Math.PI * 2;
    orb.speed = 1;
    orb.turnSpeed = Math.random() - 0.8;

    orb.x = Math.random() * bounds.width;
    orb.y = Math.random() * bounds.height;

    orb.scale.set(1 + Math.random() * 0.3);
    orb.original = new PIXI.Point();
    orb.original.copyFrom(orb.scale);

    orbs.push(orb);
  }

  // Blur the orbs
  // This seems like it could get pretty heavy pretty fast, low quality is fast but not very smooth
  container.filters = [blurFilter2];
  blurFilter2.blur = 300;
  blurFilter2.quality = 35;

  // Events
  // store cursor coords
  let mouseX;
  let mouseY;

  app.stage.on("pointermove", (event) => {
    mouseX = event.global.x;
    mouseY = event.global.y;
  });

  // Ticker variables
  let count = 0;

  // Listen for animate update
  app.ticker.add((delta) => {
    count += 0.02;

    // animate orbs
    for (let i = 0; i < orbs.length; i++) {
      const orb = orbs[i];

      orb.direction += orb.turnSpeed * 0.01;
      orb.x += Math.sin(orb.direction) * orb.speed;
      orb.y += Math.cos(orb.direction) * orb.speed;

      orb.rotation = -orb.direction - Math.PI / 2;
      orb.scale.x = orb.original.x + Math.sin(count) * 0.2;

      // wrap the orbs around as they hit the bounds
      if (orb.x < bounds.x) {
        orb.x += bounds.width;
      } else if (orb.x > bounds.x + bounds.width) {
        orb.x -= bounds.width;
      }

      if (orb.y < bounds.y) {
        orb.y += bounds.height;
      } else if (orb.y > bounds.y + bounds.height) {
        orb.y -= bounds.height;
      }
    }
  });

  // remove the blur so you can see how the orbs move
  document.getElementById("toggleBlur").addEventListener("click", (e) => {
    let currentAmount = blurFilter2.blur;
    let newAmount = parseInt(e.target.dataset.amount);
    blurFilter2.blur = newAmount;
    e.target.dataset.amount = currentAmount;
  });

</script>

</body>
</html>
